<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Page 3 | estrella</title>
  <meta name="author" content="estrella">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="estrella"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">estrella</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>I can always be what I want to be.<span class="blink-fast">∎</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">


		<i class="fa fa-heart blink-slow"></i>

		Keep and carry on.

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/10/01/热辐射与普朗克的量子假说/" >热辐射与普朗克的量子假说</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-10-01  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="一般特征与辐射场的定量描述"><a href="#一般特征与辐射场的定量描述" class="headerlink" title="一般特征与辐射场的定量描述"></a>一般特征与辐射场的定量描述</h1><h2 id="辐射能的分布函数f-v-k-r-t"><a href="#辐射能的分布函数f-v-k-r-t" class="headerlink" title="辐射能的分布函数f(v,k,r,t)"></a>辐射能的分布函数f(v,k,r,t)</h2><p>k表示传播方向的单位矢量，r是空间场点的位矢，t是时间<br>这个函数的意义是：在t时刻、空间r点附近单位体积内的辐射场中，(1)分布在以v为中心的频段dv内，(2)以k方向为轴的立体角元dΩ(<strong>能量是分布在空间上的物理量，显然能量值大小与辐射方向与空间范围有关</strong>)内的能量为<br>    f(v,k,r,t)（1.1）</p>
<h2 id="辐射场的能量密度U-单位体积内的辐射能-及其谱密度u-v"><a href="#辐射场的能量密度U-单位体积内的辐射能-及其谱密度u-v" class="headerlink" title="辐射场的能量密度U(单位体积内的辐射能)及其谱密度u(v)"></a>辐射场的能量密度U(单位体积内的辐射能)及其谱密度u(v)</h2><h2 id="通过面元"><a href="#通过面元" class="headerlink" title="通过面元"></a>通过面元</h2><h1 id="基尔霍夫热辐射定律"><a href="#基尔霍夫热辐射定律" class="headerlink" title="基尔霍夫热辐射定律"></a>基尔霍夫热辐射定律</h1><h2 id="表述"><a href="#表述" class="headerlink" title="表述"></a>表述</h2><h2 id="推导（思想实验）"><a href="#推导（思想实验）" class="headerlink" title="推导（思想实验）"></a>推导（思想实验）</h2><h1 id="绝对黑体和黑体辐射"><a href="#绝对黑体和黑体辐射" class="headerlink" title="绝对黑体和黑体辐射"></a>绝对黑体和黑体辐射</h1><h2 id="绝对黑体的概念"><a href="#绝对黑体的概念" class="headerlink" title="绝对黑体的概念"></a>绝对黑体的概念</h2><h1 id="斯特藩-玻尔兹曼定律和维恩位移定律"><a href="#斯特藩-玻尔兹曼定律和维恩位移定律" class="headerlink" title="斯特藩-玻尔兹曼定律和维恩位移定律"></a>斯特藩-玻尔兹曼定律和维恩位移定律</h1><h1 id="维恩公式和瑞利-金斯公式"><a href="#维恩公式和瑞利-金斯公式" class="headerlink" title="维恩公式和瑞利-金斯公式"></a>维恩公式和瑞利-金斯公式</h1><h1 id="辐射场的态分布和能均分布"><a href="#辐射场的态分布和能均分布" class="headerlink" title="辐射场的态分布和能均分布"></a>辐射场的态分布和能均分布</h1><h2 id="态密度g-v-的计算"><a href="#态密度g-v-的计算" class="headerlink" title="态密度g(v)的计算"></a>态密度g(v)的计算</h2><h2 id="平均能量ε-v-t-的计算"><a href="#平均能量ε-v-t-的计算" class="headerlink" title="平均能量ε(v,t)的计算"></a>平均能量ε(v,t)的计算</h2><h1 id="普朗克公式和能量子假说"><a href="#普朗克公式和能量子假说" class="headerlink" title="普朗克公式和能量子假说"></a>普朗克公式和能量子假说</h1>
	
	</div>
  <a type="button" href="/2018/10/01/热辐射与普朗克的量子假说/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/10/01/存放希腊字母/" >希腊字母</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-10-01  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>因为决定要在博客写基础科学的东西，所以希腊字母在我的博客里必不可少。<br>一方面在这篇文章是为了存着方便用希腊字母的时候复制粘贴，另一方面也试试能不能显示出来希腊字母</p>
<ul>
<li>Α α：阿尔法 Alpha </li>
<li>Β β：贝塔 Beta </li>
<li>Γ γ：伽玛 Gamma </li>
<li>Δ δ：德尔塔 Delte </li>
<li>Ε ε：艾普西龙 Epsilon </li>
<li>Ζ ζ ：捷塔 Zeta </li>
<li>Ε η：依塔 Eta </li>
<li>Θ θ：西塔 Theta </li>
<li>Ι ι：艾欧塔 Iota </li>
<li>Κ κ：喀帕 Kappa </li>
<li>∧ λ：拉姆达 Lambda </li>
<li>Μ μ：缪 Mu </li>
<li>Ν ν：拗 Nu </li>
<li>Ξ ξ：克西 Xi </li>
<li>Ο ο：欧麦克轮 Omicron </li>
<li>∏ π：派 Pi </li>
<li>Ρ ρ：柔 Rho </li>
<li>∑ σ：西格玛 Sigma </li>
<li>Τ τ：套 Tau </li>
<li>Υ υ：宇普西龙 Upsilon </li>
<li>Φ φ：fai Phi </li>
<li>Χ χ：器 Chi </li>
<li>Ψ ψ：普赛 Psi </li>
<li>Ω ω：欧米伽 Omega</li>
</ul>

	
	</div>
  <a type="button" href="/2018/10/01/存放希腊字母/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/09/30/串口相关寄存器/" >串口相关寄存器</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-09-30  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="状态寄存器（USART-SR）"><a href="#状态寄存器（USART-SR）" class="headerlink" title="状态寄存器（USART_SR）"></a>状态寄存器（USART_SR）</h2><p><em>状态寄存器适用于检测串口此时所处的状态。</em>它能够检测到的状态有：发送寄存器空位、发送完成位、读数据寄存器非空位、检测到主线空闲位、过载错误为等等。</p>
<p>这边主要关注两个位：RXNE和TC（第5、6两位）。</p>
<ul>
<li>RXNE（读数据寄存器非空）：<br>当该位被置1的时候，就是提示已经有数据被接收到了，并且可以读出来了（即RDR移位寄存器中的数据被转移到USART_DR寄存器中）。这时候要做的就是尽快读取USART_DR，从而将该位清零，也可以向该位写0，直接清除。</li>
<li>TC（发送完成）：<br>当该位被置1的时候，表示USART_DR内的数据已经被发送完成了。如果设置了这个位的中断，则会产生中断。该位也有两种清零方式：读USART_SR，写USART_DR；直接向该位写0。</li>
</ul>
<h2 id="数据寄存器（USART-DR）"><a href="#数据寄存器（USART-DR）" class="headerlink" title="数据寄存器（USART_DR）"></a>数据寄存器（USART_DR）</h2><p>USART_DR实际是包含了<strong>两个寄存器</strong>，一个专门用于发送的TDR，一个专门用于接收的RDR。</p>
<p>进行发送数据操作时，往USART_DR写入数据会自动存储在TDR内；当进行读取数据操作时，向USART_DR读取数据会自动提取RDR数据。串行通信时一位一位传输的，所以TDR和RDR寄存器都是介于系统总线和移位寄存器间的；</p>
<p>发送数据时把TDR内容转移到发送移位寄存器上，接收数据时则是把接收到的每一位顺序保存在接收移位寄存器内进而转移到RDR。</p>
<h2 id="波特率寄存器-（USART-BRR）"><a href="#波特率寄存器-（USART-BRR）" class="headerlink" title="波特率寄存器 （USART_BRR）"></a>波特率寄存器 （USART_BRR）</h2><p>波特率寄存器包括定义了两个部分：DIV_Mantissa（整数部分）和DIV_Fraction（小数部分）。</p>
<h2 id="控制寄存器（USART-CRx）"><a href="#控制寄存器（USART-CRx）" class="headerlink" title="控制寄存器（USART_CRx）"></a>控制寄存器（USART_CRx）</h2><p>控制寄存器主要是设置USART使能、检验控制使能、校验选择（奇校验偶校验）、PE中断使能、发送缓冲区空中断使能、发送完成中断使能、接收缓冲区非空使能、发送使能、接受使能、字长等等。</p>

	
	</div>
  <a type="button" href="/2018/09/30/串口相关寄存器/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/09/27/希尔伯特的23个问题/" >希尔伯特的23个问题</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-09-27  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h3 id="1-连续统假设"><a href="#1-连续统假设" class="headerlink" title="1.连续统假设"></a>1.连续统假设</h3><p>1874年，康托猜测在可列集基数和实数基数之间没有别的基数，这就是著名的连续统假设。1938年，哥德尔证明了连续统假设和世界公认的策梅洛–弗伦克尔集合论公理系统的无矛盾性。1963年，美国数学家科亨证明连续假设和策梅洛–伦克尔集合论公理是彼此独立的。因此，连续统假设不能在策梅洛–弗伦克尔公理体系内证明其正确性与否。希尔伯特第1问题在这个意义上已获解决。</p>
<h3 id="2-算术公理的相容性"><a href="#2-算术公理的相容性" class="headerlink" title="2.算术公理的相容性"></a>2.算术公理的相容性</h3><p> 欧几里得几何的相容性可归结为算术公理的相容性。希尔伯特曾提出用形式主义计划的证明论方法加以证明。1931年，哥德尔发表的不完备性定理否定了这种看法。1936年德国数学家根茨在使用超限归纳法的条件下证明了算术公理的相容性。<br>1988年出版的《中国大百科全书》数学卷指出，数学相容性问题尚未解决。</p>
<h3 id="3-两个等底等高四面体的体积相等问题"><a href="#3-两个等底等高四面体的体积相等问题" class="headerlink" title="3.两个等底等高四面体的体积相等问题"></a>3.两个等底等高四面体的体积相等问题</h3><p>问题的意思是，存在两个等边等高的四面体，它们不可分解为有限个小四面体，使这两组四面体彼此全等。M.W.德恩1900年即对此问题给出了肯定解答。</p>
<h3 id="4-两点间以直线为距离最短线问题"><a href="#4-两点间以直线为距离最短线问题" class="headerlink" title="4.两点间以直线为距离最短线问题"></a>4.两点间以直线为距离最短线问题</h3><p> 此问题提得过于一般。满足此性质的几何学很多，因而需增加某些限制条件。1973年，苏联数学家波格列洛夫宣布，在对称距离情况下，问题获得解决。<br>《中国大百科全书》说，在希尔伯特之后，在构造与探讨各种特殊度量几何方面有许多进展，但问题并未解决。</p>
<h3 id="5-一个连续变换群的李氏概念，定义这个群的函数不假定是可微的"><a href="#5-一个连续变换群的李氏概念，定义这个群的函数不假定是可微的" class="headerlink" title="5.一个连续变换群的李氏概念，定义这个群的函数不假定是可微的"></a>5.一个连续变换群的李氏概念，定义这个群的函数不假定是可微的</h3><p> 这个问题简称连续群的解析性，即：是否每一个局部欧氏群都有一定是李群？中间经冯·诺伊曼（1933，对紧群情形）、邦德里雅金（1939，对交换群情形）、谢瓦荚（1941，对可解群情形）的努力，1952年由格利森、蒙哥马利、齐宾共同解决，得到了完全肯定的结果。</p>
<h3 id="6-物理学的公理化"><a href="#6-物理学的公理化" class="headerlink" title="6.物理学的公理化"></a>6.物理学的公理化</h3><p> 希尔伯特建议用数学的公理化方法推演出全部物理，首先是概率和力学。1933年，苏联数学家柯尔莫哥洛夫实现了将概率论公理化。后来在量子力学、量子场论方面取得了很大成功。但是物理学是否能全盘公理化，很多人表示怀疑。</p>
<h3 id="7-某些数的无理性与超越性"><a href="#7-某些数的无理性与超越性" class="headerlink" title="7.某些数的无理性与超越性"></a>7.某些数的无理性与超越性</h3><p> 1934年，A.O.盖尔方德和T.施奈德各自独立地解决了问题的后半部分，即对于任意代数数α≠0 ，1，和任意代数无理数β证明了αβ 的超越性。</p>
<h3 id="8-素数问题"><a href="#8-素数问题" class="headerlink" title="8.素数问题"></a>8.素数问题</h3><p> 包括黎曼猜想、哥德巴赫猜想及孪生素数问题等。一般情况下的黎曼猜想仍待解决。哥德巴赫猜想的最佳结果属于陈景润（1966），但离最解决尚有距离。目前孪生素数问题的最佳结果也属于陈景润。</p>
<h3 id="9．在任意数域中证明最一般的互反律"><a href="#9．在任意数域中证明最一般的互反律" class="headerlink" title="9．在任意数域中证明最一般的互反律"></a>9．在任意数域中证明最一般的互反律</h3><p> 该问题已由日本数学家高木贞治（1921）和德国数学家E.阿廷（1927）解决。</p>
<h3 id="10．-丢番图方程的可解性"><a href="#10．-丢番图方程的可解性" class="headerlink" title="10． 丢番图方程的可解性"></a>10． 丢番图方程的可解性</h3><p> 能求出一个整系数方程的整数根，称为丢番图方程可解。希尔伯特问，能否用一种由有限步构成的一般算法判断一个丢番图方程的可解性？1970年，苏联的IO.B.马季亚谢维奇证明了希尔伯特所期望的算法不存在。</p>
<h3 id="11．系数为任意代数数的二次型"><a href="#11．系数为任意代数数的二次型" class="headerlink" title="11．系数为任意代数数的二次型"></a>11．系数为任意代数数的二次型</h3><p> H.哈塞（1929）和C.L.西格尔（1936，1951）在这个问题上获得重要结果。</p>
<h3 id="12．-将阿贝尔域上的克罗克定理推广到任意的代数有理域上去"><a href="#12．-将阿贝尔域上的克罗克定理推广到任意的代数有理域上去" class="headerlink" title="12． 将阿贝尔域上的克罗克定理推广到任意的代数有理域上去"></a>12． 将阿贝尔域上的克罗克定理推广到任意的代数有理域上去</h3><p> 这一问题只有一些零星的结果，离彻底解决还相差很远。</p>
<h3 id="13．-不可能用只有两个变数的函数解一般的七次方程"><a href="#13．-不可能用只有两个变数的函数解一般的七次方程" class="headerlink" title="13． 不可能用只有两个变数的函数解一般的七次方程"></a>13． 不可能用只有两个变数的函数解一般的七次方程</h3><p> 七次方程的根依赖于3个参数a、b、c，即x=x （a，b，c）。这个函数能否用二元函数表示出来？苏联数学家阿诺尔德解决了连续函数的情形（1957），维士斯金又把它推广到了连续可微函数的情形（1964）。但如果要求是解析函数，则问题尚未解决。</p>
<h3 id="14．-证明某类完备函数系的有限性"><a href="#14．-证明某类完备函数系的有限性" class="headerlink" title="14． 证明某类完备函数系的有限性"></a>14． 证明某类完备函数系的有限性</h3><p> 这和代数不变量问题有关。1958年，日本数学家永田雅宜给出了反例。</p>
<h3 id="15．-舒伯特计数演算的严格基础"><a href="#15．-舒伯特计数演算的严格基础" class="headerlink" title="15． 舒伯特计数演算的严格基础"></a>15． 舒伯特计数演算的严格基础</h3><p> 一个典型问题是：在三维空间中有四条直线，问有几条直线能和这四条直线都相交？舒伯特给出了一个直观解法。希尔伯特要求将问题一般化，并给以严格基础。现在已有了一些可计算的方法，它和代数几何学不密切联系。但严格的基础迄今仍未确立。</p>
<h3 id="16．-代数曲线和代数曲线面的拓扑问题"><a href="#16．-代数曲线和代数曲线面的拓扑问题" class="headerlink" title="16． 代数曲线和代数曲线面的拓扑问题"></a>16． 代数曲线和代数曲线面的拓扑问题</h3><p> 这个问题分为两部分。前半部分涉及代数曲线含有闭的分枝曲线的最大数目。后半部分要求讨论的极限环的最大个数和相对位置，其中X、Y是x、y的n次多项式.苏联的彼得罗夫斯基曾宣称证明了n=2时极限环的个数不超过3，但这一结论是错误的，已由中国数学家举出反例（1979）。</p>
<h3 id="17．-半正定形式的平方和表示"><a href="#17．-半正定形式的平方和表示" class="headerlink" title="17． 半正定形式的平方和表示"></a>17． 半正定形式的平方和表示</h3><p> 一个实系数n元多项式对一切数组(x1,x2,…,xn) 都恒大于或等于0，是否都能写成平方和的形式？1927年阿廷证明这是对的。</p>
<h3 id="18．-用全等多面体构造空间"><a href="#18．-用全等多面体构造空间" class="headerlink" title="18． 用全等多面体构造空间"></a>18． 用全等多面体构造空间</h3><p> 由德国数学家比勃马赫（1910）、荚因哈特（1928）作出部分解决。</p>
<h3 id="19．-正则变分问题的解是否一定解析"><a href="#19．-正则变分问题的解是否一定解析" class="headerlink" title="19． 正则变分问题的解是否一定解析"></a>19． 正则变分问题的解是否一定解析</h3><p> 对这一问题的研究很少。C.H.伯恩斯坦和彼得罗夫斯基等得出了一些结果。</p>
<h3 id="20．-一般边值问题"><a href="#20．-一般边值问题" class="headerlink" title="20． 一般边值问题"></a>20． 一般边值问题</h3><p> 这一问题进展十分迅速，已成为一个很大的数学分支。目前还在继续研究。</p>
<h3 id="21．-具有给定单值群的线性微分方程解的存在性证明"><a href="#21．-具有给定单值群的线性微分方程解的存在性证明" class="headerlink" title="21． 具有给定单值群的线性微分方程解的存在性证明"></a>21． 具有给定单值群的线性微分方程解的存在性证明</h3><p> 已由希尔伯特本人（1905）和H.罗尔（1957）的工作解决。</p>
<h3 id="22．-由自守函数构成的解析函数的单值化"><a href="#22．-由自守函数构成的解析函数的单值化" class="headerlink" title="22． 由自守函数构成的解析函数的单值化"></a>22． 由自守函数构成的解析函数的单值化</h3><p> 它涉及艰辛的黎曼曲面论，1907年P.克伯获重要突破，其他方面尚未解决。</p>
<h3 id="23．-变分法的进一步发展出"><a href="#23．-变分法的进一步发展出" class="headerlink" title="23． 变分法的进一步发展出"></a>23． 变分法的进一步发展出</h3><p> 这并不是一个明确的数学问题，只是谈了对变分法的一般看法。20世纪以来变分法有了很大的发展</p>

	
	</div>
  <a type="button" href="/2018/09/27/希尔伯特的23个问题/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/09/18/sigcomm2018阅读笔记/" >sigcomm2018阅读笔记</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-09-18  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="主要会议一Congestion-Monitoring-and-Control监控网络拥挤"><a href="#主要会议一Congestion-Monitoring-and-Control监控网络拥挤" class="headerlink" title="主要会议一Congestion Monitoring and Control监控网络拥挤"></a>主要会议一Congestion Monitoring and Control监控网络拥挤</h2><h3 id="1-1Inferring-Persistent-Interdomain-Congestion-推断网络拥挤"><a href="#1-1Inferring-Persistent-Interdomain-Congestion-推断网络拥挤" class="headerlink" title="1.1Inferring Persistent Interdomain Congestion 推断网络拥挤"></a>1.1Inferring Persistent Interdomain Congestion 推断网络拥挤</h3><h4 id="网络拥挤的原因：Interconnection-disputes-resulted-in-congestion：内部连接的矛盾造成拥堵"><a href="#网络拥挤的原因：Interconnection-disputes-resulted-in-congestion：内部连接的矛盾造成拥堵" class="headerlink" title="网络拥挤的原因：Interconnection disputes resulted in congestion：内部连接的矛盾造成拥堵"></a>网络拥挤的原因：Interconnection disputes resulted in congestion：内部连接的矛盾造成拥堵</h4><p>No data was available for third-party to study these links：但第三方没有数据了解这些连接（以调控）</p>
<h4 id="上面这个原因造成的后果："><a href="#上面这个原因造成的后果：" class="headerlink" title="上面这个原因造成的后果："></a>上面这个原因造成的后果：</h4><p>Congestion on transit links affects parties other than those involved in the dispute 拥堵的传输连接除了内部连接矛盾的直接参与者还影响了其他(没有内部连接矛盾)的人<br>Limited data available to regulators and researchers to increase transparency and empirical grounding of debate数据有限所以管理员和调研人员只能力所能及的做出经验性的推理<br>Our goal: third-party inference of congestion at interdomain interconnections我们的目标是让网络拥挤时提供第三方接口<br>Scientiﬁc approach to achieving this goal involves challenges in network inference, system development and data mining科学界试图从网络接口，系统升级，数据挖掘方面解决这个问题</p>
<h4 id="“我”方贡献："><a href="#“我”方贡献：" class="headerlink" title="“我”方贡献："></a>“我”方贡献：</h4><p>Methodology: Operationalized a lightweight method for third-party inference of interdomain congestion, conducted thorough validation理论系统：通过确认实施第三方接口的轻量理论<br>System: Built data collection and analysis platform to support the entire scientiﬁc workﬂow, and enable others to access and further study the data (ongoing) 系统：为了实现整个理论进行收集平台数据分析<br>Observations: Studied 8 large U.S. broadband providers from March 2016 to Dec 2017 (data collection ongoing)观察：研究美国March 2016 to Dec 2017的宽带情况</p>
<h4 id="Method-Time-Series-Latency-Probes拥挤潜伏时间调查"><a href="#Method-Time-Series-Latency-Probes拥挤潜伏时间调查" class="headerlink" title="Method: Time Series Latency Probes拥挤潜伏时间调查"></a>Method: Time Series Latency Probes拥挤潜伏时间调查</h4><p>Peak-hour congestion ﬁlls up router buffers, resulting in elevated latency across an interdomain link  顶峰时间路径缓存全满，导致潜伏时间提高How do we measure latency across an interdomain link?我们如何测量拥堵潜伏？</p>
<h4 id="Time-Series-Latency-Probes-TSLP-时间序列潜伏探针"><a href="#Time-Series-Latency-Probes-TSLP-时间序列潜伏探针" class="headerlink" title="Time Series Latency Probes (TSLP)时间序列潜伏探针"></a>Time Series Latency Probes (TSLP)时间序列潜伏探针</h4><p>repeat to obtain a time series重复以获得时间序列<br><em>RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。<br>往返延时(RTT)由三个部分决定：即链路的传播时间、末端系统的处理时间以及路由器的缓存中的排队和处理时间。其中，前面两个部分的值作为一个TCP连接相对固定，路由器的缓存中的排队和处理时间会随着整个网络拥塞程度的变化而变化。所以RTT的变化在一定程度上反映了网络拥塞程度的变化。简单来说就是发送方从发送数据开始，到收到来自接受方的确认信息所经历的时间。</em></p>
<h4 id="Pieces-of-the-Puzzle难点"><a href="#Pieces-of-the-Puzzle难点" class="headerlink" title="Pieces of the Puzzle难点"></a>Pieces of the Puzzle难点</h4><p> Interdomain link Identiﬁcation: Need to identify interdomain links to be able to probe them识别拥挤的内部连接<br>Adaptive Probing: Need to be adaptive to changes in the underlying topology and routing<br>需要适应潜在的拓扑和路径变化<br>Identifying Congested Links: Need time-series analysis techniques to ﬁnd patterns in (noisy) data that indicate congestion识别拥挤连接（和第一个什么区别？）<br>Validation: Need to validate inferences. Most peering agreements are covered by NDAs需要确认接口，大多数没有认证的协议要被保密协议覆盖</p>
<h4 id="总结：这是一篇检测网络拥挤情况的方法的论文。后面实验结果就没看了。。"><a href="#总结：这是一篇检测网络拥挤情况的方法的论文。后面实验结果就没看了。。" class="headerlink" title="总结：这是一篇检测网络拥挤情况的方法的论文。后面实验结果就没看了。。"></a>总结：这是一篇检测网络拥挤情况的方法的论文。后面实验结果就没看了。。</h4><h2 id="主要会议二Routing路由"><a href="#主要会议二Routing路由" class="headerlink" title="主要会议二Routing路由"></a>主要会议二Routing路由</h2><h3 id="1-Internet-Anycast-Performance-Problems-and-Potential"><a href="#1-Internet-Anycast-Performance-Problems-and-Potential" class="headerlink" title="1.Internet Anycast: Performance, Problems and Potential"></a>1.Internet Anycast: Performance, Problems and Potential</h3><p>Anycast 指IPV6协议中一个发送方同最近的一组接收方之间的通信。（路由系统选择“最近”的结点为源结点提供服务，从而在一定程度上为源结点提供了更好的服务也减轻了网络负载）<br>网络路由就近算法：表现 问题和发展趋势</p>
<h4 id="问题：Anycast-often-chooses-poorly就近算法经常选择路径非常愚蠢"><a href="#问题：Anycast-often-chooses-poorly就近算法经常选择路径非常愚蠢" class="headerlink" title="问题：Anycast often chooses poorly就近算法经常选择路径非常愚蠢"></a>问题：Anycast often chooses poorly就近算法经常选择路径非常愚蠢</h4><p> Actual distribution: Many queries go to distant sites实际的情况是，许多查询请求去了很远的站点<br>Video below used queries from D-root on Dec. 1st 2016域名根2016年的视频请求？？？？什么意思</p>
<h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><p>表现：Do queries go to nearby anycast sites? Does adding anycast sites help？请求会去最近的站点吗？如果增加站点能改善吗?<br>问题：并不，可为什么呢？<br>潜能：我们怎么修复？</p>
<h4 id="Do-queries-go-to-nearby-sites-Does-adding-anycast-global-sites-help"><a href="#Do-queries-go-to-nearby-sites-Does-adding-anycast-global-sites-help" class="headerlink" title="Do queries go to nearby sites?Does adding anycast (global) sites help?"></a>Do queries go to nearby sites?Does adding anycast (global) sites help?</h4><p> We compute the extra distance each query travelled over their geographically closest site 我们估算了每一个请求去地理上离它最近的站点所走的额外路程<br> But most queries should have short extra distance 结果是蛮多请求本来可以走更短的路程的<br>Over 1/3 queries traveled more than 1000km extra distance<br> We analyze longitudinal RIPE Atlas measurements 我们分析了维度方向上的RIPE组织的测量值<br>RIPE是一个独立的非盈利性的会员组织，是五个提供互联网资源分配的地区之一，支持全世界范围内互联网的注册和协调活动最突出的活动，RIPE是作为区域互联网注册提供全球互联网资源和相关服务（的IPv4 ， IPv6和数目 资源）的成员在网络协调中心服务区。其成员主要由 互联网服务提供商（ ISP ） ，电信机构和大型企业组成 主要设在欧洲，以及中东和中亚部分地区。<br> Evaluate performance of 9 DNS roots in 2017 评价17年九个域名管理系统根的表现<br>Compute average query distance in each week估算每周请求的距离<br>Site counts hardly matter站点数几乎没有影响</p>
<h4 id="Why-doesn’t-anycast-work-as-expected？"><a href="#Why-doesn’t-anycast-work-as-expected？" class="headerlink" title="Why doesn’t anycast work as expected？"></a>Why doesn’t anycast work as expected？</h4><p>Routing and topology constraints introduce path inﬂation  路程和拓扑限制导致了路径膨胀<br>The actual path is longer than the shortest 实际路程比最短的更长<br>However, path inﬂation in anycast is different但路径膨胀在anycast里是不同的<br>Directs packets away from the closest anycast site引导把最短路径点打包带走<br>Path inﬂation in unicast（单播流） is like taking a detour导航似的<br>Path inﬂation in anycast is like ﬂying to a different Cambridge直线一般<br>Anycast &amp; unicast path inﬂation：（路程距离区别）<br>Unicast inﬂation: Diﬀerence between the predicted latency to geographically closest site, and latency to lowest latency site. 地理最近<br>Anycast inﬂation: Diﬀerence between latency to lowest latency site, and latency to selected site.拥堵程度最低<br>Anycast path inﬂation is larger than unicast path inﬂation用anycast和unicast分别预估，结果anycast比unicast拥堵更严重</p>
<h4 id="Would-the-best-routes-comply-with-typical-routing-policies-最好的路线遵从典型路径政策吗？"><a href="#Would-the-best-routes-comply-with-typical-routing-policies-最好的路线遵从典型路径政策吗？" class="headerlink" title="Would the best routes comply with typical routing policies?最好的路线遵从典型路径政策吗？"></a>Would the best routes comply with typical routing policies?最好的路线遵从典型路径政策吗？</h4><p>Find the ‘decision point’ where they diverge 找到它们选错的点<br>Examine if the better route is not selected due to:检查是不是因为以下原因错选<br>AS prefers routes through its customer ASes over the peer ASes, over its provider ASes：AS （访问服务器(ACCESSSERVER)）peer其他同等的<br>AS prefers routes with shortest AS path length最短的AS路径<br>Given routes with equal preference to different sites, BGP usually chooses poorly边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议<br>pets wsk</p>
<h4 id="Embedding-geographic-information-in-BGP-announcements在BGP通告中完善地理信息"><a href="#Embedding-geographic-information-in-BGP-announcements在BGP通告中完善地理信息" class="headerlink" title="Embedding geographic information in BGP announcements在BGP通告中完善地理信息"></a>Embedding geographic information in BGP announcements在BGP通告中完善地理信息</h4><p> Embed geographic location of the anycast sites reachable through the announcement 在协议中完善可达到的site的地理信息<br>Use BGP community attributes属性<br>Two 16-bit values X:Y  X represents the AS number that sets the community<br>Y encodes the  latitude and longitude经纬度与数量</p>
<h4 id="Evaluate-the-geographic-hint-through-simulation-with-real-network-traces评估模拟网络传输的地理阻碍"><a href="#Evaluate-the-geographic-hint-through-simulation-with-real-network-traces评估模拟网络传输的地理阻碍" class="headerlink" title="Evaluate the geographic hint through simulation with real network traces评估模拟网络传输的地理阻碍"></a>Evaluate the geographic hint through simulation with real network traces评估模拟网络传输的地理阻碍</h4><p>Using the traceroutes from each RIPE Atlas probe traceroute 是用来检测发出数据包的主机到目标主机之间所经过的网关数量的工具。<br>to the selected site  and to lowest-latency site 在我们选择的site和最低拥堵的site<br>Identify the ‘decision point’ 识别决定点<br>Identify the geo-closest site to the ‘decision point’, refer to as geo-hinted site 识别决定点查询是不是地理阻碍点<br>Beneﬁts of geo-hint is the difference between latency to geo-hinted site and to selected site地理阻碍的优势是地理阻碍和拥堵阻碍间的区别</p>
<h4 id="Other-results"><a href="#Other-results" class="headerlink" title="Other results"></a>Other results</h4><p>Anycast does not distribute trafﬁc in a balanced manner anycast算法能算出不阻碍交通<br>Performance problems in anycast are common across deployments部署问题中anycast问题是很普遍的<br>RIPE-Atlas measurements overrepresent Europe, but this effect only over-estimates anycast performance这个地图的测量只在欧洲实施，但他的结果能完全预测anycast问题<br>Unicast management addresses for anycast sites are good representatives unicast替anycast的安排路径也是有见地的<br>Customized community attributes are more effective than expected, given the default conﬁguration in most routers完善的信息是很有用的</p>
<h4 id="Anycast-doesn’t-work-as-well-as-it-should-but-it-can"><a href="#Anycast-doesn’t-work-as-well-as-it-should-but-it-can" class="headerlink" title="Anycast doesn’t work as well as it should, but it can"></a>Anycast doesn’t work as well as it should, but it can</h4><p>Inefﬁciencies in anycast are excessive 进步很快<br>Queries to most DNS roots travel to distant sites 传播都很远程（有大量提升余地）<br>Adding sites hardly improves anycast performance加site没用<br>Poor route selection in BGP causes larger path inﬂation in anycast than in unicast 路程选择在anycast比在unicast坏影响更大<br>There exist equal-preference routes to closer sites 相同表现路径是存在的<br>But no mechanism to choose the best among them没办法选择<br>Incrementally deployable “geo-hints” in BGP can recover most of performance deﬁcit添加地理信息可以解决大量这种问题</p>
<h2 id="主要会议三：Wireless-Links"><a href="#主要会议三：Wireless-Links" class="headerlink" title="主要会议三：Wireless Links"></a>主要会议三：Wireless Links</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><h2 id="主要会议四：Data-Center-Networking"><a href="#主要会议四：Data-Center-Networking" class="headerlink" title="主要会议四：Data Center Networking"></a>主要会议四：Data Center Networking</h2><h3 id="1-Masking-Failures-from-Application-Performance-in-Data-Center-Networks-with-Shareable-Backup-使用可共享备份屏蔽数据中心网络中应用程序性能的失败"><a href="#1-Masking-Failures-from-Application-Performance-in-Data-Center-Networks-with-Shareable-Backup-使用可共享备份屏蔽数据中心网络中应用程序性能的失败" class="headerlink" title="1.Masking Failures from Application Performance in Data Center Networks with Shareable Backup 使用可共享备份屏蔽数据中心网络中应用程序性能的失败"></a>1.Masking Failures from Application Performance in Data Center Networks with Shareable Backup 使用可共享备份屏蔽数据中心网络中应用程序性能的失败</h3><h4 id="Today’s-Failure-Handling—Rerouting如今解决问题的方法：重新规划路线"><a href="#Today’s-Failure-Handling—Rerouting如今解决问题的方法：重新规划路线" class="headerlink" title="Today’s Failure Handling—Rerouting如今解决问题的方法：重新规划路线"></a>Today’s Failure Handling—Rerouting如今解决问题的方法：重新规划路线</h4><p>Fast local rerouting  inflated path length本地重新规划路径：路径变长<br>Global optimal rerouting  high latency of routes updates全球重新规划路径：高延迟<br>Impact flows not traveling trough the failure location影响不会流过错误的地点</p>
<h4 id="Impact-on-Coflow-Completion-Time-CCT-影响并流完成时间的因素"><a href="#Impact-on-Coflow-Completion-Time-CCT-影响并流完成时间的因素" class="headerlink" title="Impact on Coflow Completion Time (CCT)影响并流完成时间的因素"></a>Impact on Coflow Completion Time (CCT)影响并流完成时间的因素</h4><p>Facebook coflow trace脸书并流<br>k = 16 Fat-tree network胖树交换网络<br>Global optimal rerouting全球理想的重新路径规划</p>
<h4 id="Do-We-Have-Other-Options"><a href="#Do-We-Have-Other-Options" class="headerlink" title="Do We Have Other Options?"></a>Do We Have Other Options?</h4><p>Restores network capacity immediately after failure马上增加网络容量<br>Be cost efficient–Small pool of backup switch有备份的选择<br>How do we achieve that?</p>
<h4 id="Circuit-Switches电路选择"><a href="#Circuit-Switches电路选择" class="headerlink" title="Circuit Switches电路选择"></a>Circuit Switches电路选择</h4><p>Physical layer device物理层设备<br>Circuit controlled by software软件控制<br>Examples<br>–optical 2D-MEMS switch, 40us, $10 per-port cost<br>–electrical cross-point switch, 70ns, $3 per-port cost</p>
<h4 id="Ideal-Architecture理想网络结构"><a href="#Ideal-Architecture理想网络结构" class="headerlink" title="Ideal Architecture理想网络结构"></a>Ideal Architecture理想网络结构</h4><p>Entire network shares one backup switch备份开关<br>Replace any failed switch when necessary开关坏掉就替换掉<br>Unreasonable high port-count of circuit switch 电路开关的端口数很不合理<br>Single point of failure单点错误</p>
<h4 id="How-to-Make-It-Practical它怎么变得实用？"><a href="#How-to-Make-It-Practical它怎么变得实用？" class="headerlink" title="How to Make It Practical它怎么变得实用？"></a>How to Make It Practical它怎么变得实用？</h4><p>Feasibility-small port-count circuit switches可行性：少端口数的电路开关<br>Scalability-partition network into failure groups-distribute circuit switches across the network可扩展性，将电路故障网络分隔开<br>Low cost-small backup pool-share backup switches per failure groups低开销的备份分享组</p>
<h4 id="Recover-First-Diagnose-Later先覆盖后分析"><a href="#Recover-First-Diagnose-Later先覆盖后分析" class="headerlink" title="Recover First, Diagnose Later先覆盖后分析"></a>Recover First, Diagnose Later先覆盖后分析</h4><p>Failure Recovery–switch failure replaced by backups  via circuit reconfiguration–link failure switches on both side are replaced错误覆盖：电路重布局，连接错误，开关被替换<br>Automatic failure diagnosis performed offline-details in the paper自动错误分析离线执行</p>
<h4 id="What-does-control-system-do"><a href="#What-does-control-system-do" class="headerlink" title="What does control system do?"></a>What does control system do?</h4><p>Collects keep-alive messages &amp; link status reports from switches不停收集开关信息<br>Reconfigures circuit switches under failures重新布局电路<br>Performs offline failure diagnosis 完成离线错误分析<br>Implications-needs to talk to many circuit switches and packet switches-keeps a large amount of states of circuit/switch/link status含义：需要处理很多信息</p>
<h2 id="主要会议五：Applications-and-IoT"><a href="#主要会议五：Applications-and-IoT" class="headerlink" title="主要会议五：Applications and IoT"></a>主要会议五：Applications and IoT</h2><h3 id="4-MUTE-Bringing-IoT-to-Noise-Cancellation"><a href="#4-MUTE-Bringing-IoT-to-Noise-Cancellation" class="headerlink" title="4.MUTE: Bringing IoT to Noise Cancellation"></a>4.MUTE: Bringing IoT to Noise Cancellation</h3><h4 id="MUTE"><a href="#MUTE" class="headerlink" title="MUTE"></a>MUTE</h4><p> Leverage lookahead for noise cancellation.Lookahead allows us to cover ears in time</p>
<h4 id="Timing-Gain-Wideband-Cancellation了解波段的频率"><a href="#Timing-Gain-Wideband-Cancellation了解波段的频率" class="headerlink" title="Timing Gain  Wideband Cancellation了解波段的频率"></a>Timing Gain  Wideband Cancellation了解波段的频率</h4><p>Why does noise cancellation not work at higher frequencies?<br>Time budget (lookahead): 𝑡_2−𝑡_1≈3 ms (100X larger)</p>
<h4 id="Signal-Processing-Gain"><a href="#Signal-Processing-Gain" class="headerlink" title="Signal Processing Gain"></a>Signal Processing Gain</h4><h4 id="Application-Specific-Gain"><a href="#Application-Specific-Gain" class="headerlink" title="Application-Specific Gain"></a>Application-Specific Gain</h4><p>compute the anti-noise signal in time </p>
<h2 id="主要会议六：RDMA-and-Hardware-Support"><a href="#主要会议六：RDMA-and-Hardware-Support" class="headerlink" title="主要会议六：RDMA and Hardware Support"></a>主要会议六：RDMA and Hardware Support</h2><h3 id="6-2-Revisiting-Network-Support-for-RDMA-重探网络对远程内存访问的支持"><a href="#6-2-Revisiting-Network-Support-for-RDMA-重探网络对远程内存访问的支持" class="headerlink" title="6.2 Revisiting Network Support for RDMA 重探网络对远程内存访问的支持"></a>6.2 Revisiting Network Support for RDMA 重探网络对远程内存访问的支持</h3><h4 id="Rise-of-RDMA-in-datacenters-RDMA在数据中心的崛起"><a href="#Rise-of-RDMA-in-datacenters-RDMA在数据中心的崛起" class="headerlink" title="Rise of RDMA in datacenters RDMA在数据中心的崛起"></a>Rise of RDMA in datacenters RDMA在数据中心的崛起</h4><p>Enables low CPU utilization, low latency, high throughput（因为可以免除OS对硬件层面的苛刻要求）</p>
<h4 id="Current-Status现状"><a href="#Current-Status现状" class="headerlink" title="Current Status现状"></a>Current Status现状</h4><p>RoCE (RDMA over Converged Ethernet).集成以太网上的RDMA –Canonical approach for deploying RDMA in datacenters.在数据中心RDMA已经有符合规定的方法了 –Needs lossless network to get good performance.性能达到更高还需要无损网络<br> Network made lossless using Priority Flow Control (PFC). –Complicates network management. –Various known performance issues.<br>approach for deploying RDMA in datacenters. –Needs lossless network to get good performance.<br>• Network made lossless using Priority Flow Control (PFC). –Complicates network management. –Various known performance issues.<br>Is a lossless network really needed? No! Incremental changes to RoCE NIC design can enable better performance without a lossless network.</p>
<h4 id="History-of-RDMA"><a href="#History-of-RDMA" class="headerlink" title="History of RDMA"></a>History of RDMA</h4><p>RDMA traditionally used in Infinibandclusters. –Losses are rare (credit-based flow control).用在不拥挤的网络中<br>Transport layer in RDMA NICs not designed to deal with losses efficiently. –Receiver discards out-of-order packets. –Sender does go-back-N on detecting packet loss.</p>
<h2 id="主要会议七：SDN-and-Workloads-软件定义网络，是网络虚拟化的一种实现方式"><a href="#主要会议七：SDN-and-Workloads-软件定义网络，是网络虚拟化的一种实现方式" class="headerlink" title="主要会议七：SDN and Workloads 软件定义网络，是网络虚拟化的一种实现方式"></a>主要会议七：SDN and Workloads 软件定义网络，是网络虚拟化的一种实现方式</h2><h2 id="主要会议八：Wireless-Low-Power-and-High-Data-Rates是无线低功耗以及高传输速率化"><a href="#主要会议八：Wireless-Low-Power-and-High-Data-Rates是无线低功耗以及高传输速率化" class="headerlink" title="主要会议八：Wireless Low Power and High Data Rates是无线低功耗以及高传输速率化"></a>主要会议八：Wireless Low Power and High Data Rates是无线低功耗以及高传输速率化</h2><h2 id="主要会议九：Network-Verification-网络确认"><a href="#主要会议九：Network-Verification-网络确认" class="headerlink" title="主要会议九：Network Verification 网络确认"></a>主要会议九：Network Verification 网络确认</h2><h2 id="主要会议十：Measurements-测量方法"><a href="#主要会议十：Measurements-测量方法" class="headerlink" title="主要会议十：Measurements 测量方法"></a>主要会议十：Measurements 测量方法</h2>
	
	</div>
  <a type="button" href="/2018/09/18/sigcomm2018阅读笔记/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/09/15/串口接收中断/" >串口接收中断</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-09-15  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul>
<li>在改写esp8266模块驱动文件，将串口3换成串口2，遇到问题如图</li>
<li>第一部分将usart2TX接上usb转串口的RX，串口接收AT，表示串口发送正常</li>
<li>第二部分是将usart2接收的再通过串口1发送给电脑，看到只发了一个字母T</li>
<li>第三部分是直接将esp8266的TX接到usb转串口的RX，这表示第二部分也应该是这个，但是不知道为什么收到的是单个字节<br><img src="http://a2.qpic.cn/psb?/V11V3soz2JNi4c/xXxYjow2ObeuJsv6NhTwstFdls*axqoL7GzLcfqUwSQ!/c/dBEAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=iwLUAAAAAAARF30!&amp;tl=1&amp;vuin=3033668267&amp;tm=1537012800&amp;sce=60-2-2&amp;rf=0-0" alt=""><h2 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h2></li>
<li><p>这是普通串口通信的接收中断<br>  void USART2_IRQHandler(void)<br>  {<br>  u8 Res;</p>
<p>  if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)  </p>
<pre><code>{
Res =USART_ReceiveData(USART2);    

if((USART_RX_STA&amp;0x8000)==0)
    {
    if(USART_RX_STA&amp;0x4000)
        {
        if(Res!=0x0a)USART_RX_STA=0;
        else USART_RX_STA|=0x8000;    
        }
    else 
        {    
        if(Res==0x0d)USART_RX_STA|=0x4000;
        else
            {
            USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=Res ;
            USART_RX_STA++;
            if(USART_RX_STA&gt;(USART_REC_LEN-1))USART_RX_STA=0;      
            }         
        }
    }            
     } 
</code></pre><p>  } </p>
</li>
<li>这是esp8266中特殊需求的串口通信的接收中断<br>  void USART3_IRQHandler(void)<br>  {<pre><code>u8 res;          
if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
{     
    res =USART_ReceiveData(USART3);         
    if((USART3_RX_STA&amp;(1&lt;&lt;15))==0)
    { 
        if(USART3_RX_STA&lt;USART3_MAX_RECV_LEN)    
        {
            TIM_SetCounter(TIM7,0);
            if(USART3_RX_STA==0)                 
            {
                TIM_Cmd(TIM7,ENABLE);
            }
            USART3_RX_BUF[USART3_RX_STA++]=res;         
        }
        else 
        {
            USART3_RX_STA|=1&lt;&lt;15;                
        } 
    }
}                                                                
</code></pre>  }   </li>
<li>串口的接收方式可以有很多种，之前测试串口2接收功能的时候的确能很好的测试，但那次只是单次接收。像esp8266这种不停发送的，用之前的代码就不行了。按照那个算法不能在中断中执行发送接收过程，存在中断嵌套的问题，会造成只执行一次的现象。按照数据结构老师的话来说就是算法健壮性不够。<h2 id="串口的接收中断的分析"><a href="#串口的接收中断的分析" class="headerlink" title="串口的接收中断的分析"></a>串口的接收中断的分析</h2><h3 id="首先复习中断优先级"><a href="#首先复习中断优先级" class="headerlink" title="首先复习中断优先级"></a>首先复习中断优先级</h3></li>
</ul>

	
	</div>
  <a type="button" href="/2018/09/15/串口接收中断/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/09/15/关于USART_RX_STA&0X8000与USART_RX_EN/" >关于USART2_RX_STA&amp;0X8000与USART_RX_EN</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-09-15  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="USART-RX-STA-amp-0x8000"><a href="#USART-RX-STA-amp-0x8000" class="headerlink" title="USART_RX_STA&amp;0x8000"></a>USART_RX_STA&amp;0x8000</h2><ul>
<li>因为0与上任何数都是0  所以USART_RX_STA&amp;0x8000 这个表达式  只取出USART_RX_STA 的bit13~16位（8转换为2进制是0111）<br>后两位是判断有没有接收到0X0D 和 0X0A。所以 这一句  当真只取后四位即可 故是与运算<h2 id="USART-RX-STA-0x8000"><a href="#USART-RX-STA-0x8000" class="headerlink" title="USART_RX_STA|=0x8000"></a>USART_RX_STA|=0x8000</h2></li>
<li>后面之所以用或  是因为 0或上任何数都是本身，并且我们需要保留USART_RX_STA的值，故用或运算</li>
</ul>
<p>有的时候出现这样的报错，但是确确实实定义了，也包含了头文件，为什么会出现未定义的情况呢？<br><img src="http://a2.qpic.cn/psb?/V11V3soz2JNi4c/wWRVfjCCQ8DP15UcYmLLo.VncGww5roe8NMY058x5.s!/c/dA0AAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=lQRPAAAAAAARF*4!&amp;tl=1&amp;vuin=3033668267&amp;tm=1536926400&amp;sce=60-2-2&amp;rf=0-0" alt=""></p>
<p>如图，是因为粗心没看到定义在#if里面！<br><img src="http://a3.qpic.cn/psb?/V11V3soz2JNi4c/C*ftOtMztQqIKbCgXPhj4L0p64gnHVyA*EZZMQvRM9k!/c/dJoAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=OAInAQAAAAARFzw!&amp;tl=1&amp;vuin=3033668267&amp;tm=1536926400&amp;sce=60-2-2&amp;rf=0-0" alt=""></p>
<p>好像有点无聊</p>
<h2 id="if与if的区别"><a href="#if与if的区别" class="headerlink" title="#if与if的区别"></a>#if与if的区别</h2><pre><code>#if ... 
#else 
... 
#endif //与#if对应 
</code></pre><p>作为一个编译“开关”，比如： </p>
<pre><code>#if(条件满足) 
执行代码1 
#else 
执行代码2 
#endif 
</code></pre><p>  假如编译时，确实满足条件，则生成的程序文件(.exe文件)中不会有执行代码2的。如果用普通if语句，生成的程序文件就会有执行代码2，这个区别看看生成文件大小就可以知道。如果你的条件在程序编译前就已经确定了，那就用#if；如果条件需要在程序运行过程中才能判断，则用if。<br>前者是预编译命令 是为处理程序而设计的 原则上不属于程序语言的一部分，后者是if语句 </p>
<h2 id="再记"><a href="#再记" class="headerlink" title="再记"></a>再记</h2><p>刚刚又遇到了类似的问题<br><img src="http://a3.qpic.cn/psb?/V11V3soz2JNi4c/EKXNlcmisSKk*t7Yqyfc3O*QvTOb6BA3MhGTh7O0MYQ!/c/dJoAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=CQQ1AAAAAAARFxg!&amp;tl=1&amp;vuin=3033668267&amp;tm=1536933600&amp;sce=60-2-2&amp;rf=0-0" alt=""><br>明明定义了，却表示我的函数没有明确定义，原来问题出在这里<br><img src="http://a2.qpic.cn/psb?/V11V3soz2JNi4c/n6SR7EN59KOXZRvhVfVjMokY4xCcv7x5IcYiFAyZI2Q!/c/dNEAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=DQE6AAAAAAARFxY!&amp;tl=1&amp;vuin=3033668267&amp;tm=1536933600&amp;sce=60-2-2&amp;rf=0-0" alt=""><br>因为改的是一个只用usart2的工程，所以预处理指令也是</p>
<pre><code>#ifndef __USART_H
#define __USART_H
#endif    
</code></pre><p>就把串口一的给覆盖掉了，所以其实是没定义的</p>
<h2 id="尾记：发现自己对函数预处理一点也不敏感，需要重学"><a href="#尾记：发现自己对函数预处理一点也不敏感，需要重学" class="headerlink" title="尾记：发现自己对函数预处理一点也不敏感，需要重学"></a>尾记：发现自己对函数预处理一点也不敏感，需要重学</h2>
	
	</div>
  <a type="button" href="/2018/09/15/关于USART_RX_STA&0X8000与USART_RX_EN/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/09/12/stm32的半主机模式/" >printf和stm32的半主机模式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-09-12  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="半主机："><a href="#半主机：" class="headerlink" title="半主机："></a>半主机：</h2><ul>
<li>半主机是用于 ARM 目标的一种机制，可将来自应用程序代码的输入/输出请求传送至运行调试器的主机。 </li>
<li>例如，使用此机制可以启用 C 库中的函数，如 printf() 和 scanf()，来使用主机的屏幕和键盘，而不是在目标系统上配备屏幕和键盘。（开发时使用的硬件通常没有最终系统的所有输入和输出设备。 半主机可让主机来提供这些设备。）<br><strong>简单的来说，半主机模式就是通过仿真器实现开发板在电脑上的输入和输出。和半主机模式功能相同的是ITM调试机制。</strong></li>
<li>所谓重定向是指修改printf的底层函数，使printf打印到单片机的外设中</li>
<li>和半主机模式功能相同的是ITM调试机制。它们都是调试机制，开发板均借助仿真器与电脑连接，实现单片机利用主机的屏幕键盘的输入输出。<em>这两种机制的运行均需要仿真器，否则无法运行。</em></li>
<li>semihost（半主机） 仅仅是一种调试手段，它的机理就是利用MULTI_IDE等工具捕捉目标环境运行过程中产生的值为0x123456的SWI中断，然后向上位机的ADS 软件发送对应的调试信息。</li>
<li>对于我们最后的应用代码来说，<em>都是nonsemihost类型的</em>。如果我们在调试中使用semihost，那么只要在最后重定义 ADS中的一些使用到的库函数（比如fputc），代码就可以从semihost向nonsemihost的类型转变。<h2 id="开发式一般单片机需要独立运行，开发者应去掉仿真器，把printf函数通过单片机的外设来实现，例如通过开发板的串口，lcd或者sd卡。（正点原子的例程中就是通过开发板串口实现，哪怕可以接stlink调试）"><a href="#开发式一般单片机需要独立运行，开发者应去掉仿真器，把printf函数通过单片机的外设来实现，例如通过开发板的串口，lcd或者sd卡。（正点原子的例程中就是通过开发板串口实现，哪怕可以接stlink调试）" class="headerlink" title="开发式一般单片机需要独立运行，开发者应去掉仿真器，把printf函数通过单片机的外设来实现，例如通过开发板的串口，lcd或者sd卡。（正点原子的例程中就是通过开发板串口实现，哪怕可以接stlink调试）"></a>开发式一般单片机需要独立运行，开发者应去掉仿真器，把printf函数通过单片机的外设来实现，例如通过开发板的串口，lcd或者sd卡。（正点原子的例程中就是通过开发板串口实现，哪怕可以接stlink调试）</h2></li>
</ul>
<h2 id="printf到串口实现方式"><a href="#printf到串口实现方式" class="headerlink" title="printf到串口实现方式"></a>printf到串口实现方式</h2><h3 id="使用微库："><a href="#使用微库：" class="headerlink" title="使用微库："></a>使用微库：</h3><ul>
<li>不用强调关掉半主机模式，使用微库的话,不会使用半主机模式</li>
<li>C库中实现的是printf函数，不是fputc，fputc是printf调用的硬件接口函数<br>1.使用微库(平台式keil-MDK），点击“魔术棒” Target标签下有个Use MicroLIB,勾选。<br>2.包含头文件:#include “stdio.h”<br>3.printf重定向，修改fputc()函数的内容<br>  int fputc(int ch, FILE *f)<br>  {<pre><code>USART_SendData(DEBUG_USART, (unsigned char) ch);
while (!(DEBUG_USART-&gt;SR &amp; USART_FLAG_TXE));
return (ch);
</code></pre>  }</li>
</ul>
<h3 id="不使用微库"><a href="#不使用微库" class="headerlink" title="不使用微库"></a>不使用微库</h3><ul>
<li><p>要强调不使用半主机（no semihosting）模式）<br>1、包含头文件#include “stdio.h”<br>2、重写fputc，但需要先加点东西：<br>  #pragma import(__use_no_semihosting)//强调不使用半主机<br>  _sys_exit(int x)<br>  {</p>
<pre><code>x = x;
</code></pre><p>  }<br>  struct __FILE<br>  {</p>
<pre><code>int handle;
</code></pre><p>   };</p>
<p>  FILE __stdout;<br>  int fputc(int ch, FILE *f)<br>  {</p>
<pre><code>USART_SendData(DEBUG_USART, (unsigned char) ch);
while (!(DEBUG_USART-&gt;SR &amp; USART_FLAG_TXE));
return (ch);
</code></pre><p>  }</p>
</li>
</ul>
<h2 id="微库"><a href="#微库" class="headerlink" title="微库"></a>微库</h2><ul>
<li>microlib 是缺省（默认的意思） C 库的备选库。 </li>
<li>它用于必须在极少量内存环境下运行的深层嵌入式应用程序。 </li>
<li>这些应用程序不在操作系统中运行。</li>
<li>microlib 不会尝试成为符合标准的 ISO C 库。</li>
<li>microlib 进行了高度优化以使代码变得很小。 </li>
<li>它的功能比缺省 C 库少，并且根本不具备某些ISO C特性。</li>
<li>某些库函数的运行速度也比较慢，例如，memcpy()。</li>
</ul>

	
	</div>
  <a type="button" href="/2018/09/12/stm32的半主机模式/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/08/08/陀螺仪原始数据处理/" >陀螺仪原始数据处理</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-08-08  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>参考自<a href="https://blog.csdn.net/u013636775/article/details/69668860" target="_blank" rel="noopener">https://blog.csdn.net/u013636775/article/details/69668860</a></p>
<h1 id="陀螺仪测量角速度"><a href="#陀螺仪测量角速度" class="headerlink" title="陀螺仪测量角速度"></a>陀螺仪测量角速度</h1><ul>
<li>陀螺仪的范围有±250、±500、±2000可选，而对应的精度分别是131LSB/(°/s)、65.5LSB/(°/s)、32.8LSB/(°/s)、16.4 LSB/(°/s)</li>
<li>首先MPU6050数据寄存器是一个16位的，由于最高位是符号位，故而数据寄存器的输出范围是-7FFF~7FFF ,也既是-32767~32767</li>
<li>如果选择陀螺仪范围是±2000，那么意味着-32767对应的是-2000(°/s)，32767对应是2000(°/s)其他数值计算即可。<h1 id="加速度计计算加速度"><a href="#加速度计计算加速度" class="headerlink" title="加速度计计算加速度"></a>加速度计计算加速度</h1></li>
<li>当AFS_SEL=3时，数字-32767对应-16g，32767对应16g。把32767除以16，就可以得到2048， 即我们说的灵敏度。把从加速度计读出的数字除以2048，就可以换算成加速度的数值（以一个g为单位）<h3 id="总而言之就是自己选量程，量程大精度小，量程小精度大，单位一个是角度制每秒，一个是弧度制每秒，转化一下国际单位制"><a href="#总而言之就是自己选量程，量程大精度小，量程小精度大，单位一个是角度制每秒，一个是弧度制每秒，转化一下国际单位制" class="headerlink" title="总而言之就是自己选量程，量程大精度小，量程小精度大，单位一个是角度制每秒，一个是弧度制每秒，转化一下国际单位制"></a>总而言之就是自己选量程，量程大精度小，量程小精度大，单位一个是角度制每秒，一个是弧度制每秒，转化一下国际单位制</h3></li>
</ul>

	
	</div>
  <a type="button" href="/2018/08/08/陀螺仪原始数据处理/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/08/08/关于USE_STDPERIPH_DRIVER/" >关于USE_STDPERIPH_DRIVER</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-08-08  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<ul>
<li>基于库函数的例程里面预定义都有USE_STDPERIPH_DRIVER，而基于寄存器开发的例程里没有这个预定义</li>
<li>作用：USE_STDPERIPH_DRIVER ： to use or not the peripheral’s drivers in application code (i.e. code will be based on direct access to peripheral’s registers rather than drivers API) , this option is controlled by the #define USE_STDPERIPH_DRIVER<br>  即这个定义控制了是否在应用中启用外设驱动。我们使用标准外设库本来就为了方便控制外设，所以要添加这个定义，以启用外设驱动。</li>
<li>程序：程序的执行是从“main.c”文件开始的，其中必须包含有头文件“stm32f10x.h”。我们打开“stm32f10x.h”，按下“Ctrl+F”键，查找USE_STDPERIPH_DRIVER，在“Find What”栏中输入“USE_STDPERIPH_DRIVER”。如图-3所示。点击“Find<br>Next”,出现“USE_STDPERIPH_DRIVER”对应的代码行。只有用预编译指令预定义了“USE_STDPERIPH_DRIVER”，才会将”stm32f10x_conf.h”包含进“stm32f10x.h”中，从而被”main.c”用到。<em>这就解释了，为什么我们没有在“main.c”中包含”stm32f10x_conf.h”，而在编译之后却被包含进了”main.c”中。</em><h3 id="stm32f10x-conf-h"><a href="#stm32f10x-conf-h" class="headerlink" title="stm32f10x_conf.h"></a>stm32f10x_conf.h</h3></li>
<li>新版的固件库V3.0以上 main等源文件中不再直接包含stm32f10x_conf.h，而是stm32f10x.h，stm32f10x.h则定义了启动设置，以及所有寄存器宏定义</li>
<li>stm32f10x_conf.h中包含了所有外设的头文件，因此任意源文件只要包含了stm32f10x.h，就可以在源文件调用任意外设的函数。<br>若有外设为使用到，在stm32f10x_conf.h注释相应部分，项目编译时就不会在编译去掉的外设</li>
</ul>

	
	</div>
  <a type="button" href="/2018/08/08/关于USE_STDPERIPH_DRIVER/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
     <a href="/page/2/" type="button" class="btn btn-default"><i class="fa fa-arrow-circle-o-left"></i> Prev</a>
      

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/4/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories//">  <span>2</span></a></li>
		
			<li><a href="/categories/html/">html<span>1</span></a></li>
		
			<li><a href="/categories/matlab/">matlab<span>4</span></a></li>
		
			<li><a href="/categories/stm32/">stm32<span>1</span></a></li>
		
			<li><a href="/categories/上位机/">上位机<span>1</span></a></li>
		
			<li><a href="/categories/传感器/">传感器<span>2</span></a></li>
		
			<li><a href="/categories/单片机/">单片机<span>16</span></a></li>
		
			<li><a href="/categories/博客/">博客<span>3</span></a></li>
		
			<li><a href="/categories/后端/">后端<span>1</span></a></li>
		
			<li><a href="/categories/嵌入式/">嵌入式<span>4</span></a></li>
		
			<li><a href="/categories/数学/">数学<span>1</span></a></li>
		
			<li><a href="/categories/树莓派/">树莓派<span>3</span></a></li>
		
			<li><a href="/categories/物理/">物理<span>2</span></a></li>
		
			<li><a href="/categories/物联网/">物联网<span>3</span></a></li>
		
			<li><a href="/categories/网络安全/">网络安全<span>4</span></a></li>
		
			<li><a href="/categories/英语/">英语<span>1</span></a></li>
		
			<li><a href="/categories/计算机网络/">计算机网络<span>1</span></a></li>
		
			<li><a href="/categories/软件使用/">软件使用<span>2</span></a></li>
		
			<li><a href="/categories/随想/">随想<span>1</span></a></li>
		
			<li><a href="/categories/顶会顶刊/">顶会顶刊<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/c语言/">c语言<span>1</span></a></li>
		
			<li><a href="/tags/多核/">多核<span>1</span></a></li>
		
			<li><a href="/tags/wifi/">wifi<span>2</span></a></li>
		
			<li><a href="/tags/单片机/">单片机<span>1</span></a></li>
		
			<li><a href="/tags/基于模型的设计/">基于模型的设计<span>1</span></a></li>
		
			<li><a href="/tags/技术外语文档/">技术外语文档<span>1</span></a></li>
		
			<li><a href="/tags/量子物理/">量子物理<span>1</span></a></li>
		
			<li><a href="/tags/数学/">数学<span>1</span></a></li>
		
			<li><a href="/tags/matlab/">matlab<span>5</span></a></li>
		
			<li><a href="/tags/定时器中断/">定时器中断<span>2</span></a></li>
		
			<li><a href="/tags/图片外链/">图片外链<span>1</span></a></li>
		
			<li><a href="/tags/MySQL/">MySQL<span>1</span></a></li>
		
			<li><a href="/tags/定时器/">定时器<span>1</span></a></li>
		
			<li><a href="/tags/html/">html<span>1</span></a></li>
		
			<li><a href="/tags/后端/">后端<span>1</span></a></li>
		
			<li><a href="/tags/顶会/">顶会<span>1</span></a></li>
		
			<li><a href="/tags/HC-05/">HC-05<span>1</span></a></li>
		
			<li><a href="/tags/mathematica/">mathematica<span>2</span></a></li>
		
			<li><a href="/tags/工程模板/">工程模板<span>1</span></a></li>
		
			<li><a href="/tags/上位机/">上位机<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>53</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2021/01/21/ACCESS偏移注入/" ><i class="fa fa-file-o"></i>ACCESS偏移注入</a>
      </li>
    
      <li>
        <a href="/2021/01/20/MySQL注入学习记录/" ><i class="fa fa-file-o"></i>MySQL注入的学习记录</a>
      </li>
    
      <li>
        <a href="/2021/01/15/ACCESS注入学习记录/" ><i class="fa fa-file-o"></i>ACCESS注入学习记录</a>
      </li>
    
      <li>
        <a href="/2021/01/01/ACCESS常用表名列名/" ><i class="fa fa-file-o"></i>ACCESS常用表名列名</a>
      </li>
    
      <li>
        <a href="/2019/07/03/matlab开发stm32初学笔记/" ><i class="fa fa-file-o"></i>matlab开发stm32初学笔记</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/hexo-theme-freemind" title="Freemind's Github repository." target="_blank"]);">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/kristopolous/BOOTSTRA.386" title="BOOTSTRA.386's Github repository." target="_blank"]);">BOOTSTRA.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/blackshow/hexo-theme-freemind.386" title="Freemind.386's Github repository." target="_blank"]);">Freemind.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/blackshow" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2021 estrella
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
